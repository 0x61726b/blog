---
layout: post
title: "Yume Engine - Light Shafts"
modified: 2015-11-23 00:01:26 +0200
tags: [yume,programming,direct3d11,light shafts,light beams,godrays,god rays,c++,graphics programming]
image:
  feature: blogshaft.jpg
  credit:
  creditlink:
comments:
share:
---

There is a way to achieve light shafts/god rays/light beams without too much of a work.As described [here](http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html)
 god rays can be achieved with a simple trick.It wont be very accurate but we'll get results. To achieve this effect

 1. Render everything normally
 2. Render quad with the light shaft shader as the backbuffer bound as SRV
 3. Gaussian blur
 4. Gaussian blur(vertical)
 5. Tonemapping

 The "shaft" effect comes from the second pass,blur passes and tonemapping is not necessary but it looks good.The math behind the effect is explained in the Gpu Gems 3 papers so if you want to check it out its free.

 Only parameter needed for the shaft shader is *screen position of sun* . Well since this technique only applies for directional lights and directional lights have not really a position you need to fake a position.Since the position must be in screen space you have to multiply it by *ViewProj* matrix.

 Here are some results

 Values used are:


 **Weight** : 0.08
 **Decay**  : 0.95
 **Exposure** : 0.4
 **Samples** : 100


 ![](http://i.imgur.com/jhi44QL.jpg)

 ![](http://i.imgur.com/61mRXuH.jpg)

 ![](http://i.imgur.com/ZmloQwz.png)


  **Weight** : 0.12
  **Decay**  : 0.95
  **Exposure** : 0.9
  **Samples** : 100


 ![](http://i.imgur.com/Bu77geL.jpg)

 ![](http://i.imgur.com/yJkcqsl.jpg)


 **Weight** : 0.22
 **Decay**  : 0.90
 **Exposure** : 0.25
 **Samples** : 100


![](http://i.imgur.com/MaGCLZW.jpg)



 Here are what passes look like on VS Debugger

 Light Shaft Generate Pass
 ![](http://i.imgur.com/c3iilhp.png)

 Horizontal Gaussian Blur with 8 samples
 ![](http://i.imgur.com/RnrzEC7.png)

 Vertical Gaussian Blur with 8 samples
 ![](http://i.imgur.com/lzZ2Nn7.png)

 Combine with backbuffer
 ![](http://i.imgur.com/I2s6D67.png)


 Here are 2 videos of the effect

 [Video 1](https://www.youtube.com/watch?v=5FhhMwFkEHA)

 [Video 2](https://www.youtube.com/watch?v=ajX3bVhLLs8)


 Now to the HLSL code!


```

 void PS(float2 iTexCoord : TEXCOORD0,
         float2 iScreenPos : TEXCOORD1,
     out float4 oColor : OUTCOLOR0)
 {
#ifdef GODRAY_PASS
 	  float4 pos = cLightPosScreen; //Screen position of the sun
 		float depth = Sample2D(DepthBuffer, iScreenPos); //Sample2D is just a macro,here,it equals to tDepthBuffer.Sample(sDepthBuffer,iScreenPos)
 		float2 deltaTex = (iScreenPos - pos.xy) / cLSSampleCount;
 		float3 color = Sample2D(DiffMap,iScreenPos).xyz;
 		float illuminationDecay = 1.0f;
 		for (int i = 0; i < cLSSampleCount; i++)
 		{
 			iScreenPos -= deltaTex;
 			float3 s = Sample2D(DiffMap, iScreenPos).xyz; //Diffmap is the backbuffer texture generated by rendering everything normally
 			s *= illuminationDecay * cLSWeight;
 			color += s;
 			illuminationDecay *= cLSDecay;
 		}
 		oColor = float4(color * cLSExposure,depth);
#endif
#ifdef COMBINE
    //This is the last pass,after blurring EmissiveMap is the blurred 'godray' map
 		float3 original = Sample2D(DiffMap, iScreenPos) * 0.9f;
 		float3 shaft = Sample2D(EmissiveMap, iScreenPos) * 0.6f;
 		original *= saturate(1.0 - shaft);
    oColor = float4(original + shaft, 1.0);
 #endif
 }


```

 I hope this is helpful to someone.
